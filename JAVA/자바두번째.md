#  문자열 다루기 1

- String [] 라는 문자열 배열

- class 내 외부에 모두 가능, 지역변수, 전역변수로 사용 가능

- 대신 외부에 두려면 static 이란걸 붙혀야함

- 입력받는데는 마찬가지로 Scanner를 사용하자.

### Lesson.java

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Lesson {
	
//		지금은 지역변수로 사용, 함수 외부에 둬서 전역 변수처럼 사용할 수도 있음
//	대신 외부에 두려면 static 이란걸 붙혀야함
	static String [] names = new String [1000]; 
	static int [] numbers = new int[1000];
//	int [] numbers;
//	numbers = new int [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
		Scanner sc;
		try {
			sc = new Scanner( new File("input.txt") );			
			
			while(sc.hasNext() ) {
				
				names[n] = sc.next(); 
				numbers[n] = sc.nextInt();
				n++;
			}
			
			sc.close();
			
		} catch (FileNotFoundException e) {	// 해당파일이 없으면 어쩔거냐 정하는 부분, 무조건 해야되는건아님.
			System.out.print("No file"); //내 맘대로 처리하면 됨.
			System.exit(1);
		}

		bubbleSort(n, names, numbers);
		
		for (int i=0; i<n; i++) {
			System.out.println(names[i] + "," +  numbers[i] );
			
		}
		

	}
	
	static public void bubbleSort(int n, String [] names, int [] numbers)// call-by-value
	{
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( names[j].compareTo(names[j+1] ) > 0 ) {  // ==0  str1.equals(str2) 문자열 같은지 비교하기 
					// swqp numbers [j] and numbers [j+1]
					int tmp = numbers[j];
					numbers[j] = numbers[j+1];
					numbers[j+1] = tmp;
							
					String tmpstr = names[j];
					names[j] = names[j+1];
					names[j+1] = tmpstr;
				} 			
				
			}
		}
	}
}
```



# 문자열 다루기2

- #### 인덱스 메이커

- 입력으로 하나의 텍스트 파일 일기
- 텍스트 파일에 등장하는 단어들의 목록 만들고, 단어가 텍스트 파일에 등장하는 횟수 세기
- 사용자가 요청하면 단어 목록을 하나의 파일로 저장
- 사용자가 단어 검색하면 단어가 텍스트 파일에 몇번 등장하는지 출력

- `java.lang.ArrayIndexOutOfBoundsException` 오류 => 배열의 인덱스를 벗어났다.

- `PrintWriter out`

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				addWord(str);  // 목록에서 검사해서 상황에 따라 다르게하기
			}
			
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static void addWord(String str) {
		int index = findWord( str );	// returns -1 if not found
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			words[n] = str;
			count[n] = 1;
			n++;
		}
	}
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 문자열 다루기 3

- code 22 개선하자!
- 소수점, 특수기호가 단어에 포함, 숫자 등이 단어에 포함, 대소문자는 맨밑에 수정해서 됬지만, 알파벳 순서대로 ㄱㄱ
- String 클래스 기본 메서드

![1](https://user-images.githubusercontent.com/45934115/58763366-af0c8c80-8594-11e9-96f3-83acc079320c.PNG)



- ex) "-?*he-llo+=() 면 he-llo 가 남게 하겠다!

### Code23 이 되어야하지만 Code 22에 쓴 친구

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && words[i].compareTo(str) > 0) {
				words[i+1] = words[i];
				count[i+1] = count[i];
				i--;
			}
			words[i+1] = str;
			count[i+1] = 1;
			n++;
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 1

- 전화번호를 예로 들때 이름, 번호를 각자 다른 배열에 저장하는게 불편하다고 할 수있다.
- 왜냐면 함께하지 않으면 의미가 없는 데이터로 취급되기 때문이다 쌍으로 존재할때 의미있는 데이터
- 한 사람에 대해 5, 6개 이상의 데이터를 저장한다고 생각해보면 이해하기 쉽겠지

###  클래스란..

> - 한 사람의 "이름"과 "전화번호"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이 두 가지 데잍를 서로 별개의 변수에 저장하면 우리가 이름 데이터를 옮길 때 마다 전화번호 데이터도 따로 옮겨줘야 한다.
> - 만약 각 사람에 대해서 이름과 전화번호 뿐만 아니라 주소, 이메일 등 여러 가지 데이터를 저장한다면 이 불편은 더 심해질 것이다.
> - 인덱스 메이커 프로그램에서도 "하나의 단어"와 그 단어의 "등장 횟수"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이렇게 서로 관련있는 데이터들을 하나의 단위로 묶어두면 편할 것이다.
> - 이것이 클래스라는 개념이 등장하는 가장 기본적인 이유이다.
> - 클래스는 결국 하나의 `타입` 이다.     마치 int x에 5를 저장하는 것 처럼 Person1 a에 어떤걸 저장하겠다 이런 느낌
> - 다만 int, double 처럼 Java가 미리 정해놓은 타입이 아니라 사용자가 정의한 새로운 타입이라는 의미에서 `사용자 정의타입`이라고 부르기도 한다.
> - int 혹은 double형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
>
> ```java
> int count = 0;
> Person1 first = newPerson1();
> ```
>
> 

- 하나의 파일에 하나의 클래스라고 생각하자!



### Person1.java

```java
package Section1;

public class Person1 {
		
	public String name;	// 우선 public이 뭔진 궁금해하지말자		field, data member
	public String number;
	
}

```



### Code01.java

```java
package Section1;

public class Code01 {

	public static void main(String[] args) {
		
		int x;
		x = 100;
		
		double y = 1.0023;
		
		Person1 first;
		first = new Person1();  // new 는 생성하는 행위 이 생성한 것이 object(객체)
		
		// 위 아래 구조를 보쟈 비슷하다.
		// 마찬가지로 합칠 수 있다.
		
		int [] data;
		data = new int [100];
		data[0] = 5;		
		
		first.name = "John";			// first 객체의 name필드, number 필드에 저장하기
		first.number = "0102483120";
		
		System.out.println("Name: " + first.name + ", Number: " + first.number );
		
		// 배열도 된다    배열 한칸한칸이 Person1 타입을 갖는 배열을 만든거.
		Person1 [] members = new Person1 [10];
		members[0] = first;
		members[1] = new Person1();
		members[1].name = "David";
		members[1].number = "2873548327458";
		
		System.out.println("Name: " + members[1].name + ", Number: " + members[1].number );
		
		
	}

}
```



### 프리미티브 타입 vs 클래스

![class1](https://user-images.githubusercontent.com/45934115/58777691-79a28600-860a-11e9-8f6b-1d75079e1805.JPG)

- first라는 변수 안에 이름, 번호가 저장되는게 아니고   객체(object)는 new 명령으로 따로 만들어야 하고, 변수 first 안에는 참조를 저장한다. 주소를 저장한다.



### 클래스와 객체

![class2](https://user-images.githubusercontent.com/45934115/58777802-09e0cb00-860b-11e9-90bb-9ba4539bdfbe.JPG)



## 쉽게 설명하자면

- ### 모든 프리미티브 타입의 변수는 보통 변수이다.

- ### 즉 변수 자체에 값이 저장된다.

- ### 프리미티브 타입이 아닌 모든 변수는 참조 변수이다.

- ### 즉 실제 데이터가 저장될 "객체"는 new 명령으로 따로 만들어야 하고, 참조 변수에는 그 객체의 주소를 저장한다.



# 클래스, 객체, 참조변수 2



- int 는 프리미티브 타입이지만, int [] int형 배열은 프리미티브 타입이 아니다.
- 그렇기 때문에 members 는 참조변수이겠지...?    각 칸은 int 타입의 프리미티브 변수

![class3](https://user-images.githubusercontent.com/45934115/58779338-90e47200-8610-11e9-9f6e-3282078bbb9c.JPG)



- Person1 []  members = new Person1[8];
- 에서 members는 당연히 참조변수, 각 칸은 Person1이라는 타입을 갖게 됨. 위의 것이 int 타입이듯이.
- 따라서 저 한칸은 Person1타입의 참조변수 이다. 



### 값에 의한 호출:배열

![class4](https://user-images.githubusercontent.com/45934115/58779685-a4dca380-8611-11e9-9e72-ead499c8b187.JPG)



- 변수 배열 data는 복사될 때 주소를 복사시켜줘서 data라는 친구랑 data2라는 친구가 복사된 친구라면 하나만 바꿔도 둘다 변경하게 된다. 주소에 있는 값이 바뀌고, 그 것을 양쪽에서 동시에 바라보고 있기 때문에.



### Code02.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

}

```



# 클래스, 객체, 참조변수 3

- Code02에서 버블솔트 함수 추가하기!



### Code03.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		bubbleSort();	// n과 members가 메인함수 밖에 있기 때문에 매개변수가 필요 없음 ,,,즉, 지역변수가 아니다. 
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

	private static void bubbleSort() {
		
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( members[j].name.compareTo(members[j+1].name) > 0 ) {	//  compare names of j -th and (j+1) -th person
					// swap
					Person1 tmp = members[j];
					members[j] = members[j+1];
					members[j+1] = tmp;
					
					
				}
			}
		}
		
	}

}

```



- code22 수정해서 만들어보쟈 class 이용

- #### 마찬가지로 코드의 135번째 줄에서 객체를 생성해주는 것을 잊지말자!!

### Code03.java

```java
package Section1;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class IndexMaker {
	
	
//	static String [] words = new String [100000];
//	static int [] count = new int [100000];
	
	static Item [] items = new Item [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + items[index].word + " appears " + items[index].count + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(items[i].word + " " + items[i].count);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			items[index].count++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && items[i].word.compareTo(str) > 0) {
				items[i+1] = items[i];
				i--;
			}
						
			items[i+1] = new Item();		// 객체를 생성하고 거기 담는것을 잊지말자!
			items[i+1].word = str;
			items[i+1].count = 1;
			n++;
			
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (items[i].word.equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 4

- `static` 에 대한 정확한 설명은 2-3에서 수업할거지만 main함수가 있는 Code로 시작하는 파일에선
- `static`에 변수들을 저장하고 있음을 인지하고 있자.

### MyPoint1.java

```java
package Section1;

public class MyPoint1 {
	public int x;
	public int y;
	
}
```

### MyRectangle1.java

```java
package Section1;

public class MyRectangle1 {
	public MyPoint1 lu;   // left upper
	public int width;
	public int height;
}
```

### Code05.java

```java
package Section1;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;


public class Code05 {

	static MyRectangle1 [] rects = new MyRectangle1[100];   // class member
	static int n = 0;    			// 데이터의 갯수(사각형의 갯수)

	public static void main(String[] args) {
				
		try {
			Scanner in = new Scanner(new File("data.txt"));

			while(in.hasNext()) {
				
				rects[n] = new MyRectangle1(); // 실수하기 좋은 곳.... new 선언하는것..
				rects[n].lu = new MyPoint1(); // 위와 동일한 것으로, MyRectangle1에서 lu를 생성하지않았으니깐..
				rects[n].lu.x = in.nextInt();
				rects[n].lu.y = in.nextInt();
				rects[n].width = in.nextInt();
				rects[n].height = in.nextInt();
				n++;
			}
			in.close();

			
		} catch (FileNotFoundException e) {
			System.out.println("No data file.");
			System.exit(1);
		}
		
		bubbleSort();
		
		for (int i=0; i<n; i++)
			System.out.println(rects[i].lu.x + " " + rects[i].lu.y + " " + rects[i].width + " " + rects[i].height);
		

	}
	
	private static void bubbleSort() {
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( calcArea(rects[j]) > calcArea(rects[j+1])) {
					MyRectangle1 tmp = rects[j];
					rects[j] = rects[j+1];
					rects[j+1] = tmp;
				}
			}
		}
	}
	
	public static int calcArea( MyRectangle1 r)
	{
		return r.width * r.height;
	}

}

```



# 클래스, 객체, 참조변수 5

- 다항함수는 항들의 합이며 항은 계수와 지수에 의해서 정의된다. 계수는 0이 아닌 정수이고 지수는 음이 아닌 정수라고 가정한다. 

```java
f(x) = -x**5 + 2x **4 -10x -3
```



- ### 다항함수 프로그램 만들기

![class5](https://user-images.githubusercontent.com/45934115/58853087-fe0d0b80-86d3-11e9-8e10-80e2b375763c.JPG)



- `Math.pow( x, term.expo)` 지수승 계산 하는 법...



### Code06.java

```java
package Section1;

import java.util.Scanner;

public class Code06 {

	static Polynomial [] polys = new Polynomial [100];
	static int n = 0;
	
	public static void main(String[] args) {
		
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial();	// 객체 생성, 객체 안에 있는 필드들에 저장.
				polys[n].name = name;
				polys[n].terms = new Term [100];
				polys[n].nTerms = 0;
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					addTerm( polys[index], c, e);
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = calcPolynomial( polys[index], x);
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					printPolynomial( polys[index]);
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();
	}

	private static int calcPolynomial(Polynomial p, int x) {
		int result = 0;
		for (int i = 0; i<p.nTerms; i++)
			result += calcTemr( p.terms[i], x);
		return result;
	}

	private static int calcTemr(Term term, int x) {
		return (int) (term.coef * Math.pow( x, term.expo));  // 지수승 계산법
	}	//  double이 리턴될 수 있어서 타이오류가 뜨는데 (int) (어쩌구저쩌구) 써서 타입 바꿔죽...?
	private static void printPolynomial(Polynomial p) {
		for (int i=0; i<p.nTerms; i++)	{
			printTerm( p.terms[i]);		
			System.out.print("+");
		}
		System.out.println();
	}

	private static void printTerm(Term term) {
		System.out.print(term.coef + "x^" + term.expo);		
	}

	private static void addTerm(Polynomial p, int c, int e) {
		// 자기 자리 찾아서 insert하기... indexMaker 에서 해보았던 것과 비슷한 느낌.
		// 1. 이미 차수가 e인 항이 있을 경우 => 해당 것에 더해주기
		// 2. 아니면 추가하기.
		
		int index = findTerm( p, e);
		if (index != -1) {
			p.terms[index].coef += c;
			// 만약, coef항이 원래는 0이 아니었는데 더하니까 0이되는경우...?? 원랜 없애야되지만 여기선 pass!
		}
		else {
			int i = p.nTerms -1;
			while (i >=0 && p.terms[i].expo < e) {
				p.terms[i+1] = p.terms[i];
				i--;
			}
			p.terms[i+1] = new Term();	// 중요해 중요해 중요해 중요해 중요해
			p.terms[i+1].coef = c;
			p.terms[i+1].expo = e;
			p.nTerms++;
		}			
	}
	

	private static int findTerm(Polynomial p, int e) {
		for (int i = 0; i < p.nTerms && p.terms[i].expo >= e; i++)
			if (p.terms[i].expo == e)
				return i;
		return -1;
	}

	private static int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

}

```

# 메서드와 생성자 1

#### 메서드와 생성자

> - 클래스는 서로 관련있는 데이터들을 하나의 단위로 묶어두기 위한 것이다. ex) 사각형의 꼭지점
> - 하지만 이것이 전부가 아니다.
> - 서로 관련있는 데이터들 뿐 아니라, 그 데이터와 관련이 깊은 메서드(함수)도 함게 묶어 둘 수 있다.
> - 이렇게 함으로써 코드의 `응집도` (cohension)을 높이고 결합도(coupling)을 낯출 수 있다.
> - `응집도`란 연관 있는 코드들끼리 잘 모여있고... 그런 느낌? 결합도는 방, 코드는 사람 친한 친구끼리 묶어두니 방을 오갈 이유가없음



- 다항식 프로그램에서, printTerm과 calcTerm은 class Term과 매우 긴밀한 연관이 있는 메서드들. 이렇게 서로 관련성이 깊은 데이터와 메서드들을 하나의 클래스로 묶어둘 수 있다.



![메서드1](https://user-images.githubusercontent.com/45934115/58931910-8951d400-879c-11e9-8261-7cdb48e79aea.JPG)

​				



![메서드2](https://user-images.githubusercontent.com/45934115/58931983-cae27f00-879c-11e9-931a-50dba8d64469.JPG)



- class는 설계도일 뿐, 실체가 아니다.
- 개게를 만들어주고 객체 안의 메서드들이 실행되면서 존재의 의미를 갖는다.



#### 객체란?

> - 객체 지향 프로그래밍에서 객체란 "데이터" + "메서드"이다. 데이터는 객체의 "정적속성"을 표현하며, 메서드는 객체의 "기능(동적 속성)"을 표현한다.
> - 자전거는 "모양, 무게, 크기, 브랜드"등의 정적 속성(데이터)과 "달린다, 정지한다, 뒤로 간다"등의 기능을 가진다.
> - 하나의 항(term)은 "계수와 차수"라는 정적 속성과 "x의 값을 주면 자신의 값을 계산해 준다", "화면에 출력해 준다"등의 기능을 가진다.



![메서드3](https://user-images.githubusercontent.com/45934115/58932166-8c998f80-879d-11e9-95d7-4c3ffbaa70fc.JPG)



# 메서드와 생성자 2

#### 생성자

> - 클래스 안에 그 클래스와 동일한 이름을 가지며 return 타입이 없는 특별한 메서드를 둘 수 있다. 이 것을 생성자(constructor)라고 부른다.
> - 생성자는 new 명령으로 객체가 생성될 때 자동으로 실행된다. 주 목적은 객체의 데이터 필드의 값을 초기화하는 것이다.

![메서드4](https://user-images.githubusercontent.com/45934115/58934369-3c263000-87a5-11e9-9e71-53c7cd2cda3a.JPG)

- 클래스 자체 이름과 동일한 메서드...  
- return 타입이 아예 없다는 두가지 특징!



### Term3.java

```java
package section2;

public class Term3 {
	public int coef;
	public int expo;
	
	public Term3(int c, int e)
	{
		coef = c;
		expo = e;
	}
	
	public int calcTerm(int x) {
		return (int) (coef * Math.pow( x, expo));  
	}	
	
	public void printTerm() {
		System.out.print(coef + "x^" + expo);		
	}
	
}

```



### Polynomial3.java

```java
package section2;

public class Polynomial3 {
	public char name;
	public Term3 [] terms;	//	다항식의 이름
	public int nTerms; 		//	다항의 갯수
	
	
	public Polynomial3()
	{
		nTerms = 0;
		terms = new Term3 [100];
	}
	
//	타입, 받는 매개변수가 다르기 때문에 여러 생성자를 가질수 있음 동일한 이름이지만...
		
	public Polynomial3( char name)
	{
		this.name = name;   // this.name은 맨 위의 name, 뒤에 name은 매개변수 name
		nTerms = 0;
		terms = new Term3 [100];
	}
	
	public void addTerm( int c, int e ) {
		// 자기 자리 찾아서 insert하기... indexMaker 에서 해보았던 것과 비슷한 느낌.
		// 1. 이미 차수가 e인 항이 있을 경우 => 해당 것에 더해주기
		// 2. 아니면 추가하기.
		
		int index = findTerm( e );
		if (index != -1) {
			terms[index].coef += c;
			// 만약, coef항이 원래는 0이 아니었는데 더하니까 0이되는경우...?? 원랜 없애야되지만 여기선 pass!
		}
		else {
			int i = nTerms -1;
			while (i >=0 && terms[i].expo < e) {
				terms[i+1] = terms[i];
				i--;
			}
			terms[i+1] = new Term3(c, e);	// 중요해 중요해 중요해 중요해 중요해    필요없어진 밑에 두줄
//			terms[i+1].coef = c;
//			terms[i+1].expo = e;
			nTerms++;
		}			
	}
	
	
	public int findTerm( int e) {
		for (int i = 0; i < nTerms && terms[i].expo >= e; i++)
			if (terms[i].expo == e)
				return i;
		return -1;
	}
	
	
	
	
	
	public int calcPolynomial(int x) {
		int result = 0;
		for (int i = 0; i<nTerms; i++)
			result += terms[i].calcTerm(x);
		return result;
	}

	
	public void printPolynomial() {
		for (int i=0; i < nTerms; i++)	{
			terms[i].printTerm();		
			System.out.print("+");
		}
		System.out.println();
	}
	
}

```



### Code08.java

```java
package section2;

import java.util.Scanner;

public class Code08 {

	static Polynomial3 [] polys = new Polynomial3 [100];
	static int n = 0;
	
	public static void main(String[] args) {
		
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial3( name );	// 객체 생성, 객체 안에 있는 필드들에 저장.
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					 polys[index].addTerm( c, e );
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = polys[index].calcPolynomial(x); // 멤버로 갖고있어서..
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					polys[index].printPolynomial();
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();
	}
	



	private static int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

}

```

- toString() 이라는 이름은 특별한 아이 이렇게 해주는게 좋음...  이름을 꼭 이렇게 지어주기로하자.

- 코드의 응집도를 높였을 때의 장점,,
  - 어떤 이유 때문에 사각형 하나를 표현할 때 꼭지점, 너비, 높이를 이용할 때와 대각선 꼭지점 두개를 이용해서 표현 할 때 Code09도  엄청나게 수정해서 써야되는데,
  - 저런 표현 방법을 쓰면 MyRectangle2만 고치면 된다.
  - 



### MyPoint2.java

```java
package section2;

public class MyPoint2 {
	public int x;
	public int y;
	
	public MyPoint2( int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}


```



### MyRectangle2.java

```java
package section2;

public class MyRectangle2 {
	public MyPoint2 lu;   // left upper
	public int width;
	public int height;
	
	public MyRectangle2( int x, int y, int w, int h) {
		lu = new MyPoint2( x, y );
		width = w;
		height = h;
	}
	
	public int calcArea( )
	{
		return width * height;
	}
	
	
	// toString() 이라는 이름은 특별한 아이 이렇게 해주는게 좋음... 
	public String toString()
	{
		return "(" + lu.x + " " + lu.y + ")" + width + " " + height;
	}	
}
```



### Code09.java

```java
package section2;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;


public class Code09 {

	static MyRectangle2 [] rects = new MyRectangle2[100];   // class member
	static int n = 0;    			// 데이터의 갯수(사각형의 갯수)

	public static void main(String[] args) {
				
		try {
			Scanner in = new Scanner(new File("data.txt"));

			while(in.hasNext()) {
				
				int x = in.nextInt();
				int y = in.nextInt();
				int w = in.nextInt();
				int h = in.nextInt();
				
				rects[n] = new MyRectangle2( x, y, w, h); // 실수하기 좋은 곳.... new 선언하는것..
//				rects[n++] = new MyRectangle2( in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt()); // 실수하기 좋은 곳.... new 선언하는것..
				n++;
			}
			in.close();

			
		} catch (FileNotFoundException e) {
			System.out.println("No data file.");
			System.exit(1);
		}
		
		bubbleSort();
		
		for (int i=0; i<n; i++)
			System.out.println( rects[i].toString() );	// 조금 더 코드가 간결해지는 느낌.
		
	}
	
	// 하나의 사각형에 해당하는 함수가 아니니까 버블소트는 여기 두자..
	private static void bubbleSort() {
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( rects[j].calcArea() > rects[j+1].calcArea()) {
					MyRectangle2 tmp = rects[j];
					rects[j] = rects[j+1];
					rects[j+1] = tmp;
				}
			}
		}
	}
}

```



# 메서드와 생성자3

#### 다각형과 점

- 입력으로 하나의 직교 다각형과 또 하나의 점 p가 주어질 대 그 점이 다각형의 ㅐㄴ부에 있는지 외부에 있는지 판단하는 프로그램을 만들어보자!

- 점에서 시작하여 한 방향으로 무한히 뻗어가는 아무 직선이나 하나 그어서 그것이 다각형의 변과 짝수번 교차하면 외부, 홀수 번 교차하면 내부에 있다.



### OrthoPolygon.java

```java
package section2;

public class OrthoPolygon {
	
	public int n;
	public MyPoint2 [] vertices; // 꼭지점

	// 다각형 객체 생성,
	public OrthoPolygon( int k ) {	// 꼭지점의 갯수
		n = 0;	// 실제로 저장된 꼭지점의 갯수
		vertices = new MyPoint2 [k];
			
	}
	
	// 꼭지점 차례로 하나씩 추가해주는 메서드
	public void addVertex( int x, int y)
	{
		
		vertices[n++] = new MyPoint2(x, y);
	
	}
	
	public int maxX()
	{
		int max = vertices[0].x;
		for (int i=0; i<n; i++ ) {
			if (vertices[i].x > max)
				max = vertices[i].x;
		}
		return max;
	}
	
	public boolean contains( MyPoint2 p ) {
		
		OrthoLine arrow = new OrthoLine( p, new MyPoint2( maxX()+1, p.y ) );
		int count = 0;
		for (int i=0; i<n; i++) {
			OrthoLine edge = new OrthoLine( vertices[i], vertices[ (i+1) % n ] );
			if ( arrow.intersects(edge))
				count++;
		}
		return (count % 2 == 1);    //홀수면 포함
	}
	
}

```



### OrthoLine.java

```java
package section2;

public class OrthoLine {
	public MyPoint2 u;
	public MyPoint2 v;
	
	public OrthoLine ( MyPoint2 p, MyPoint2 q)
	{
		u = p;
		v = q;
		if ( p.x > q.x || p.x == q.x && p.y > q.y)
			swap();
	}
	
	private void swap() {
		MyPoint2 tmp = u;
		u = v;
		v = tmp;		
	}

	public OrthoLine (int x1, int y1, int x2, int y2)
	{
		u = new MyPoint2(x1, y1);
		v = new MyPoint2(x2, y2);
	}
		
	public boolean isVertical()	// 어차피 수직 아니면 수평이니깐
	{
		return u.x == v.x;	// true
	}
	
	
	// 이미 자신이 선분 하나의 메서드 중 하나인데.... 선분 2개를 받아서 받는건 역량 초과인듯...
	// 그니까 하나 더 추가로 받아서 비교해보는게 옳은 방법같음.
	public boolean intersects( OrthoLine other )
	{
		if ( isVertical() && !other.isVertical() ) 	// 내가 수직 니가 수평
			return ( other.u.x < u.x && other.v.x > u.x && u.y < other.u.y && v.y > other.u.y);   
		
		else if (!isVertical() && other.isVertical()) 	// 니가 수직 내가 수평
			return ( other.u.y < u.y && other.v.y > u.y && u.x < other.u.x && v.x > other.u.x );
		
		else 
			return false;
	}
	
	
}

```



### MyPoint2.java

```java
package section2;

public class MyPoint2 {
	public int x;
	public int y;
	
	public MyPoint2( int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}


```





# static 그리고 public1

#### 클래스와 객체

> - 클래스는 `타입`이다. 집이 아니라 집의 설계도이다. 즉, `실체가 아니다`.
>
> - 따라서 클래스의 데이터 필드에 데이터를 저장할 수는 없고, 클래스의 멤버 메서드를 실행할 수도 없다. 왜냐하면 실체가 아니므로!!
>
> - new 명령으로 해당 클래스 타입의 객체를 만든 후, 그 객체에 데이터를 저장하고, 그 객체의 멤버 메서드를 실행하는 것이다.
>
> - 여기에는 하나의 예외가 존재하는데 그것이 static 멤버이다.
>
> - #### static 멤버는 클래스 안에 실재로 존재하며 객체에는 존재하지 않는다.



#### Static vs Non-static

![sataic1](https://user-images.githubusercontent.com/45934115/59082028-0a8ba100-892c-11e9-819b-503e34044da5.JPG)

- ex) 집의 설계도가 있다면 그것은 실체가 아닌데 문짝하나가 static으로 설계되어있으면 그 문짝은 실물인 느낌...

- static 멤버는 class 멤버다, non-static 멤버는 object 멤버다.
- non-static 멤버는 2개의 객체를 만든다면 각각의 변수가 다르게 존재한다. 객체마다 하나씩
- static 변수 s는 하나만 유일하게 존재한다.
- non-static 멤버 t 는 여러개 가능.



#### Questions

> - 왜 main 메서드는 반드시 static 이어야 하는가??
>
>   - java에서 프로그램들은 class들의 집합이다. 
>   - 따라서 main 함수도 class 안에 들어가야 한다.
>   - 근데 class는 다 허상이고 설계도일뿐이니깐 main함수가 문제가 된다 실행도안되고하니까...
>   - 누군가가 new 명령어로 그 객체 안의 것을 실행하면 되지만, main 자체가 프로그램의 시작점이니깐 static이 될 수 밖에 없다. 만약 그렇지 않다면 아무것도 실행되지않고 프로그램 자체가 허상이 되기 때문에
>
> - 왜 static 메서드에서 같은 클래스의 non-static 멤버를 엑서스 할수 없는가?
>
>   - 즉, main함수가 아닌 다른 class에서는 static으로 선언한 적이 없는데 main class 안에서는 모든 메서드를 static으로 선언한 이유
>
> ```java
> package section2;
> 
> public class Test1 {
> 	
> 	static int s = 0;		// 얘는 Test1이라는 class의 멤버
> 	int t = 0;				// 얘는 Test1에는 실제로 존재하는 친구가 아닌걸로 됨
> 	
> 	public static void print1()
> 	{
> 		System.out.println("s = " + s);
> //		System.out.println( "t = " + t);	// 왜 static method에서 static member(s)를 엑서스하는덴 오류 안뜨고
> 	}										// non-static member(t)를 엑서스하면 오류가 뜰까??
> 											// Test1이라는 타입을 생성 하고, t를 실존하게 해줘야함.
> 	
> 	
> 	public void print2()					// Test 객체를 생성해야만 print2라는 method를 존재하게 해줌
> 	{
> 		System.out.println("s = " + s);		//
> 		System.out.println("t = " + t);		// 생성하면 t도 같이 존재하게 되니깐. 문제가 없다.
> 	}
> 	
> 	public static void main(String []args)
> 	{
> 		s = 100;
> 		
> //		t = 100;
> 		print1();
> //		print2();
> 		
> 		Test1 test2 = new Test1();
> 		test2.t = 100;
> 		test2.print2();
> 		// 이렇게 써줘야함.	
> 	}	
> }
> ```
>
>   - 규칙이 아니라 static 멤버가 뭔지를 알면 자연히 알게되는 것.
>
> - 다른 클래스에 속한 static 멤버는 어떻게 엑세스 하는가?
>
>   - ```java
>    package section2;
>    ```
>  ```
> 
>  ```
>
> public class TestTest {
>
> 	public static void main(String[] args) {
> 		
> 		Test test1 = new Test();
> 		
> 		test1.t = 10;
>
> //		test1.s = 100;
> 		
> 		Test.s = 100;		// 이게 맞음
>
> //		test1.print1();
> 		
> //		Test.print1();		// 이게 맞음
> 		
> 		
> 		test1.print2();		// print2는 얘가 맞음
>
>
> ​		
> //		t와 print2() 는 자연스러운 것, 객체멤버이니까 test1이 참조하고 있는 객체멤버니깐.
> //		나머지는 test1이라는 객체 안에 있는게 아님.test라는 클래스 안에 있음.
>
> 		Test test2 = new Test();
> 		
> 		Test.print1();
> 		test2.print2();
>
> //		s는 class에 속한 멤버라서, test1이건 test2건 s의 값을 한번 바꾸면, 클래스를 사용한 모든
> //		s가 다 바뀜. 동일한 변수를 쓰는거니깐..
> 	}
>
> }
> ```
> 
>   - non - static 멤버는 참조변수.멤버 // static 멤버는 class이름.static멤버 이렇게 엑세스함
> 
> - static 메서드 / 필드의 용도는?
> 
>   - static 멤버의 용도
>     - main메서드는 무조건 static
>     - 상수 혹은 클래스 당 하나만 유지하고 있으면 되는 값(혹은 객체)
>       - ex) `Math.PI`, `System.out`	앞의것의 class 안에 뒤의것의 static이 있는 것.
>     - 순수하게 기능만으로 정의되는 메서드. 대표적인 예로는 수학 함수들
>       - ex) `Math.abs(k)`, `Math.sqrt(n)`, `Math.min(a,b)` 
> ```
>
> ```
> 
> ```

### Code11.java

```java
package section3;

import java.util.Scanner;

public class Code11 {

	Polynomial3 [] polys = new Polynomial3 [100];
	int n = 0;
	
	public void processCommand()
	{
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial3( name );	// 객체 생성, 객체 안에 있는 필드들에 저장.
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					 polys[index].addTerm( c, e );
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = polys[index].calcPolynomial(x); // 멤버로 갖고있어서..
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					polys[index].printPolynomial();
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();		
	}
	
	private int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

	
	// main을 제외한 어떤 것도 static이 아니게 하는 방법..
	// static과 non-static에 대한 혼란을 최소화 하는 방법 정도지 무조건 이렇게 해야 되는건 아님.
	public static void main(String[] args) 
	{
		Code11 app = new Code11();
		app.processCommand();		
	}
}

```



# static 그리고 public 2

- 우선은 클래스 안의 데이터 필드 앞, 생성자 앞, 메서드 앞에 있는 public 키워드의 의미



#### 접근 제어(access modifier): public, private, default, protected(상속 배우고 ㄱㄱ)

> - public : 클래스 외부에서 접근이 가능하다.
> - private : 클래스 내부에서만 접근이 가능하다.
> - default : 동일 패키지에 있는 다른 클래스에서 접근 가능하다.
> - protected : 동일 패키지의 다른 클래스와 다른 패키지의 하위클래스에서도 접근 가능하다.

- Polynomial3와 Code 11, Term3의 경우 Term3에서 public이라고 썼기에 Code11, Polynomial3에서 해당 변수 등을 사용할 수 있게 된 것이다.
- private 멤버는 해당 클래스 안에서만 쓸 수 있는 것이다...
- public과 private는 양 극단이라고 볼 수 있음.



#### 데이터 캡슐화	(Abstract *Data* Type) == 전부 성안에 두고, 대신 성문을 하나 만들자(public method)

> - 모든 데이터 멤버를 private로 만들고 필요한 경우에 public한 get/set 메서드를 제공한다.
> - 이렇게 하면 객체가 제공해주는 메서드를 통하지 않고서는 객체 내부의 데이터에 접근할 수가 없다.
> - 이것을 data encapsulation 혹은 information hiding이라고 부른다.

ex) 

- refactor에서 Encapsulate Field 사용...

```java
public int expo;
==>private int expo;
public int getExpoo()	//getter method, accessor 라고 부름.	setter method도 있음
{
    return expo;
}

차이, 값을 읽을 수는 있다, 변경은 안됨 
```

- 외부에서 직접 access 할 일이 없으면 private으로 하는게 나은듯....
- 무분별한 접근으로 프로그램의 오류가 생기는 것을 방지하기 위해서.
- 기본적인 객체지향 언어는 모든 것을 private로 하고, getter, setter를 public으로 만들어서 다른 곳에서 사용하도록 method만드는 것이 기본.



# 상속 1

#### 예시..

- A computer has
  - manufacturer
  - processor
  - RAM
  - disk
  - processor speed



### Computer.java

```java
package section1;

public class Computer {
	
	public String manufacturer;
	public String processor;
	public int ramSize;
	public int diskSize;
	public double processorSpeed;

//	public Computer(String man, String proc, int ram, int disk, double procSpeed) {
//		manufacturer = man;
//		processor = proc;
//		ramSize = ram;
//		diskSize = disk;
//		processorSpeed = procSpeed;
//	}
	
	public double computerPoser() {
		return ramSize * processorSpeed;
	}
	
	public double getRamSize() {
		return ramSize;
	}
	
	public double getProcessorSpeed() {
		return processorSpeed;
	}
	
	public int getDiskSize() {
		return diskSize;
	}
	
	public String toString() {
		String result = "Manufacturer: " + manufacturer + 
						"\nCPU: " + processor +
						"\nRAM: " + ramSize + " megabytes" +
						"\nDisk: " + diskSize + "gigabytes" +
						"\nProcessor speed: " + processorSpeed + " gigahertz";
		return result;
	}
}
```

- Notebook class 새로 만들어보자 컴퓨터 class를 조금 확장하여 내가 필요한 정보 몇개를 더 넣고서.

  

### Notebook.java

```java
package section1;

public class Notebook extends Computer {	// 확장하여보자는 뜻, 
											// 데이터, 메서드를 Computer class에서 상속받아서
											// manufacturer, processor 등을 가지고있게 된다.
					
	public double screenSize;				// 추가하고 싶은 멤버들만 추가하면 된다.
	public double weight;
	
	public static void main(String [] args) {
		
		Notebook test = new Notebook();		// Notebook class가 Computer class를 상속받아서
		test.manufacturer = "Dell";			// 갖고있다 해당 사항을
		test.processor = "i5";
		test.ramSize = 4;
		test.diskSize = 1000;
		test.processorSpeed = 3.2;
		
		test.screenSize = 15.6;
		test.weight = 1.2;
		
		System.out.println( test.computerPower() );
		
	}	
}
```

- #### Computer class와 Notebook class 는 IS-A 관계
  - ​     super class					subclass
  - ​     base class			          extended class
  - ​     parent class                   child class



- ex) 사람   -   학생 관계
  
- 사람이 가진 것을 학생이 다 갖고 있고, 학생은 학생이기에 갖는 학번, 학교 등을 추가로 가지고 있다.
  
- ex) 탈것  -  자동차

- ex) 자동차  -  세단

- #### 클래스의 데이터 멤버의 이름과 생성자에서 매개변수의 이름이 똑같을 때는 분간이 안가니깐 this.~~~라고 써주자.



- ### computer class에도 생성자가 있고, notebook class에도 생성자가 있으면 notebook 생성자에 오류표시가 뜨게됨.	왜 뜨는질 알아보자..



### 상속과 생성자

> - 생성자가 없을 경우 자동으로 no-parameter 생성자가 만들어진다(우리 눈에 보이지 않는다. 매개변수도 딱히 받지않고, 껍질만 있는 그런 느낌..).   생성자가 하나라도 있을 경우 자동으로 만들어지지 않는다.
> - 모든 서브 클래스의 생성자(Notebook)는 먼저 수퍼클래스의 생성자(Computer)를 호출한다.
>   - 1. super(...) 를 통해 명시적으로 호출해 주거나,
>     2. 그렇지 않을 경우에는 자동으로 no-parameter 생성자가 호출된다.
> - 흔한 오류:
>   - 수퍼클래스에 no-parameter 생성자가 없는데, 서브 클래스의 생성자에서 super(...)호출을 안해주는 경우..



### Notebook.java 에서 super 선언을 해주는 경우

```java
package section1;

public class Notebook extends Computer {	// 확장하여보자는 뜻, 
											// 데이터, 메서드를 Computer class에서 상속받아서
											// manufacturer, processor 등을 가지고있게 된다.
					
	public double screenSize;				// 추가하고 싶은 멤버들만 추가하면 된다.
	public double weight;
	
	
	// 생성자 만들기.
	public Notebook( String man, String proc, int ram, int disk, double speed, double screen, double weight) {
		super( man, proc, ram, disk, speed );	// Computer class에 no-parameter 생성자가 없어서 생기는 오류를 고치는 방법
		
//		manufacturer = man;			super 쓰면서 밑의 부분들이 필요 없어짐.
//		processor = proc;
//		ramSize = ram;
//		diskSize = disk;
//		processorSpeed = speed;
		screenSize = screen;
		this.weight = weight;	
	}
	
	public static void main(String [] args) {
		
		Notebook test = new Notebook("Dell", "i5", 4, 1000, 3.2, 15.6, 1.2);		// Notebook class가 Computer class를 상속받아서
//		test.manufacturer = "Dell";			// 갖고있다 해당 사항을
//		test.processor = "i5";
//		test.ramSize = 4;
//		test.diskSize = 1000;
//		test.processorSpeed = 3.2;
//		
//		test.screenSize = 15.6;
//		test.weight = 1.2;
		
		System.out.println( test.computerPower() );		
	}	
}

```



# 상속 2

- `method overriding`이란 부모로 부터 상속 받은 method가 100% 내 맘에 안드니깐 내 맘대로 고칠 수 있다.. 라는것

- data 멤버를 public으로 두는 것은 좋은 습관이 아닌데 그동안 그렇게 해두긴 했었다.

- 이번엔 데이터를 private로 고치고, getter, setter method를 사용해보자.

- 근데 Computer class와 Notebook class가 남이라고 보는게 맞나..? 그동안과는 상황이 다르다.

- 그치만 부모자식간이라도 private는 공유하지 않는 것이 규칙이다.

- #### 이런 때에 protected를 사용하면 원하는 느낌을 얻을 수 있다.

  - 전혀 엉뚱한 놈은 access 안되고, 자식 class에서는 access 하게 해준다.
  - 이건 대표적인 private와의 차이점중 하나지 전부는 아니다.

- #### 같은 부분을 두번 적는 것은 불편하다...

  - 이 부분은` super.toString()` 을 이용하여 고칠  수 있다. 



### Notebook.java toString method overriding 하기..

```java
	public String toString() {
		String result = super.toString() +         // 이 부분이 밑의 주석부분을 대신할 수 있다.
//						"Manufacturer: " + manufacturer + 
//						"\nCPU: " + processor +
//						"\nRAM: " + ramSize + " megabytes" +
//						"\nDisk: " + diskSize + "gigabytes" +
//						"\nProcessor speed: " + processorSpeed + " gigahertz" +
						"\nScreen Size: " + screenSize + " inches" +
						"\nWeight: " + weight + " kg";
					
		
		return result;
	}
```



# 상속 3

- ### 다형성 : Polymorphism(매우 중요)

  - #### 수퍼클래스 타입의 변수가 서브 클래스 타입의 객체를 참조할 수 있다. 

  - 프리미티브 타입이 아니라는 것에서 이미 참조 변수이니깐 당연한 소리이긴 하다.

  - java 프로그램, 객체 지향 프로그램의 꽃.

![다형성](https://user-images.githubusercontent.com/45934115/59175719-889cb180-8b91-11e9-8109-910ea9acbd3e.JPG)

- 앞의 부분에서 참조변수의 타입과 참조하는 객체가 항상 같았는데 이번엔 super class type의 참조변수가 subclass의 참조 변수를 참조해도 오류가 아니라는 어찌보면 간단한 논리.

```java
	public static void main(String [] args) {
		
		Computer test = new Notebook("Dell", "i5", 4, 1000, 3.2, 15.6, 1.2);		
		
		System.out.println( test.computerPower() );		
		System.out.print(test.toString());
					
	}	
```

- 하지만 이 반대로는 안됨.



- ### 왜 이건 되고 반되는 안되는지를 알아보자.(실제 의미는..?)



- 만약 위의 방식으로 선언하면 밑의 `test.toString()` 은 `Computer`의 것을 호출할까 `Notebook`의 것을 호출할까? 
  - 둘 다 일리가 있기 때문에 그냥 규칙의 문제이다. 만약 test의 타입이 `Computer`type 이기 때문에 `Computer` 것이라고 한다면 이것을 `static binding` 이라고 하고, 객체는 `Notebook` 객체이기 떄문에 `Notebook`의 것이라고 한다면  이것을 `dynamic binding`이라고 한다.
  - java에서는 규칙을 딱 정해서 `dynamic binding`이 일어난다. 항상.



