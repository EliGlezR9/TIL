#  문자열 다루기 1

- String [] 라는 문자열 배열

- class 내 외부에 모두 가능, 지역변수, 전역변수로 사용 가능

- 대신 외부에 두려면 static 이란걸 붙혀야함

- 입력받는데는 마찬가지로 Scanner를 사용하자.

### Lesson.java

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Lesson {
	
//		지금은 지역변수로 사용, 함수 외부에 둬서 전역 변수처럼 사용할 수도 있음
//	대신 외부에 두려면 static 이란걸 붙혀야함
	static String [] names = new String [1000]; 
	static int [] numbers = new int[1000];
//	int [] numbers;
//	numbers = new int [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
		Scanner sc;
		try {
			sc = new Scanner( new File("input.txt") );			
			
			while(sc.hasNext() ) {
				
				names[n] = sc.next(); 
				numbers[n] = sc.nextInt();
				n++;
			}
			
			sc.close();
			
		} catch (FileNotFoundException e) {	// 해당파일이 없으면 어쩔거냐 정하는 부분, 무조건 해야되는건아님.
			System.out.print("No file"); //내 맘대로 처리하면 됨.
			System.exit(1);
		}

		bubbleSort(n, names, numbers);
		
		for (int i=0; i<n; i++) {
			System.out.println(names[i] + "," +  numbers[i] );
			
		}
		

	}
	
	static public void bubbleSort(int n, String [] names, int [] numbers)// call-by-value
	{
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( names[j].compareTo(names[j+1] ) > 0 ) {  // ==0  str1.equals(str2) 문자열 같은지 비교하기 
					// swqp numbers [j] and numbers [j+1]
					int tmp = numbers[j];
					numbers[j] = numbers[j+1];
					numbers[j+1] = tmp;
							
					String tmpstr = names[j];
					names[j] = names[j+1];
					names[j+1] = tmpstr;
				} 			
				
			}
		}
	}
}
```



# 문자열 다루기2

- #### 인덱스 메이커

- 입력으로 하나의 텍스트 파일 일기
- 텍스트 파일에 등장하는 단어들의 목록 만들고, 단어가 텍스트 파일에 등장하는 횟수 세기
- 사용자가 요청하면 단어 목록을 하나의 파일로 저장
- 사용자가 단어 검색하면 단어가 텍스트 파일에 몇번 등장하는지 출력

- `java.lang.ArrayIndexOutOfBoundsException` 오류 => 배열의 인덱스를 벗어났다.

- `PrintWriter out`

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				addWord(str);  // 목록에서 검사해서 상황에 따라 다르게하기
			}
			
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static void addWord(String str) {
		int index = findWord( str );	// returns -1 if not found
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			words[n] = str;
			count[n] = 1;
			n++;
		}
	}
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 문자열 다루기 3

- code 22 개선하자!
- 소수점, 특수기호가 단어에 포함, 숫자 등이 단어에 포함, 대소문자는 맨밑에 수정해서 됬지만, 알파벳 순서대로 ㄱㄱ
- String 클래스 기본 메서드

![1](https://user-images.githubusercontent.com/45934115/58763366-af0c8c80-8594-11e9-96f3-83acc079320c.PNG)



- ex) "-?*he-llo+=() 면 he-llo 가 남게 하겠다!

### Code23 이 되어야하지만 Code 22에 쓴 친구

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && words[i].compareTo(str) > 0) {
				words[i+1] = words[i];
				count[i+1] = count[i];
				i--;
			}
			words[i+1] = str;
			count[i+1] = 1;
			n++;
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 1

- 전화번호를 예로 들때 이름, 번호를 각자 다른 배열에 저장하는게 불편하다고 할 수있다.
- 왜냐면 함께하지 않으면 의미가 없는 데이터로 취급되기 때문이다 쌍으로 존재할때 의미있는 데이터
- 한 사람에 대해 5, 6개 이상의 데이터를 저장한다고 생각해보면 이해하기 쉽겠지

###  클래스란..

> - 한 사람의 "이름"과 "전화번호"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이 두 가지 데잍를 서로 별개의 변수에 저장하면 우리가 이름 데이터를 옮길 때 마다 전화번호 데이터도 따로 옮겨줘야 한다.
> - 만약 각 사람에 대해서 이름과 전화번호 뿐만 아니라 주소, 이메일 등 여러 가지 데이터를 저장한다면 이 불편은 더 심해질 것이다.
> - 인덱스 메이커 프로그램에서도 "하나의 단어"와 그 단어의 "등장 횟수"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이렇게 서로 관련있는 데이터들을 하나의 단위로 묶어두면 편할 것이다.
> - 이것이 클래스라는 개념이 등장하는 가장 기본적인 이유이다.
> - 클래스는 결국 하나의 `타입` 이다.     마치 int x에 5를 저장하는 것 처럼 Person1 a에 어떤걸 저장하겠다 이런 느낌
> - 다만 int, double 처럼 Java가 미리 정해놓은 타입이 아니라 사용자가 정의한 새로운 타입이라는 의미에서 `사용자 정의타입`이라고 부르기도 한다.
> - int 혹은 double형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
>
> ```java
> int count = 0;
> Person1 first = newPerson1();
> ```
>
> 

- 하나의 파일에 하나의 클래스라고 생각하자!



### Person1.java

```java
package Section1;

public class Person1 {
		
	public String name;	// 우선 public이 뭔진 궁금해하지말자		field, data member
	public String number;
	
}

```



### Code01.java

```java
package Section1;

public class Code01 {

	public static void main(String[] args) {
		
		int x;
		x = 100;
		
		double y = 1.0023;
		
		Person1 first;
		first = new Person1();  // new 는 생성하는 행위 이 생성한 것이 object(객체)
		
		// 위 아래 구조를 보쟈 비슷하다.
		// 마찬가지로 합칠 수 있다.
		
		int [] data;
		data = new int [100];
		data[0] = 5;		
		
		first.name = "John";			// first 객체의 name필드, number 필드에 저장하기
		first.number = "0102483120";
		
		System.out.println("Name: " + first.name + ", Number: " + first.number );
		
		// 배열도 된다    배열 한칸한칸이 Person1 타입을 갖는 배열을 만든거.
		Person1 [] members = new Person1 [10];
		members[0] = first;
		members[1] = new Person1();
		members[1].name = "David";
		members[1].number = "2873548327458";
		
		System.out.println("Name: " + members[1].name + ", Number: " + members[1].number );
		
		
	}

}
```



### 프리미티브 타입 vs 클래스

![class1](https://user-images.githubusercontent.com/45934115/58777691-79a28600-860a-11e9-8f6b-1d75079e1805.JPG)

- first라는 변수 안에 이름, 번호가 저장되는게 아니고   객체(object)는 new 명령으로 따로 만들어야 하고, 변수 first 안에는 참조를 저장한다. 주소를 저장한다.



### 클래스와 객체

![class2](https://user-images.githubusercontent.com/45934115/58777802-09e0cb00-860b-11e9-90bb-9ba4539bdfbe.JPG)



## 쉽게 설명하자면

- ### 모든 프리미티브 타입의 변수는 보통 변수이다.

- ### 즉 변수 자체에 값이 저장된다.

- ### 프리미티브 타입이 아닌 모든 변수는 참조 변수이다.

- ### 즉 실제 데이터가 저장될 "객체"는 new 명령으로 따로 만들어야 하고, 참조 변수에는 그 객체의 주소를 저장한다.



# 클래스, 객체, 참조변수 2



- int 는 프리미티브 타입이지만, int [] int형 배열은 프리미티브 타입이 아니다.
- 그렇기 때문에 members 는 참조변수이겠지...?    각 칸은 int 타입의 프리미티브 변수

![class3](https://user-images.githubusercontent.com/45934115/58779338-90e47200-8610-11e9-9f6e-3282078bbb9c.JPG)



- Person1 []  members = new Person1[8];
- 에서 members는 당연히 참조변수, 각 칸은 Person1이라는 타입을 갖게 됨. 위의 것이 int 타입이듯이.
- 따라서 저 한칸은 Person1타입의 참조변수 이다. 



### 값에 의한 호출:배열

![class4](https://user-images.githubusercontent.com/45934115/58779685-a4dca380-8611-11e9-9e72-ead499c8b187.JPG)



- 변수 배열 data는 복사될 때 주소를 복사시켜줘서 data라는 친구랑 data2라는 친구가 복사된 친구라면 하나만 바꿔도 둘다 변경하게 된다. 주소에 있는 값이 바뀌고, 그 것을 양쪽에서 동시에 바라보고 있기 때문에.



### Code02.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

}

```



# 클래스, 객체, 참조변수 3

- Code02에서 버블솔트 함수 추가하기!



### Code03.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		bubbleSort();	// n과 members가 메인함수 밖에 있기 때문에 매개변수가 필요 없음 ,,,즉, 지역변수가 아니다. 
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

	private static void bubbleSort() {
		
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( members[j].name.compareTo(members[j+1].name) > 0 ) {	//  compare names of j -th and (j+1) -th person
					// swap
					Person1 tmp = members[j];
					members[j] = members[j+1];
					members[j+1] = tmp;
					
					
				}
			}
		}
		
	}

}

```



- code22 수정해서 만들어보쟈 class 이용

- #### 마찬가지로 코드의 135번째 줄에서 객체를 생성해주는 것을 잊지말자!!

### Code03.java

```java
package Section1;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class IndexMaker {
	
	
//	static String [] words = new String [100000];
//	static int [] count = new int [100000];
	
	static Item [] items = new Item [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + items[index].word + " appears " + items[index].count + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(items[i].word + " " + items[i].count);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			items[index].count++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && items[i].word.compareTo(str) > 0) {
				items[i+1] = items[i];
				i--;
			}
						
			items[i+1] = new Item();		// 객체를 생성하고 거기 담는것을 잊지말자!
			items[i+1].word = str;
			items[i+1].count = 1;
			n++;
			
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (items[i].word.equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 4

- `static` 에 대한 정확한 설명은 2-3에서 수업할거지만 main함수가 있는 Code로 시작하는 파일에선
- `static`에 변수들을 저장하고 있음을 인지하고 있자.

### MyPoint1.java

```java
package Section1;

public class MyPoint1 {
	public int x;
	public int y;
	
}
```

### MyRectangle1.java

```java
package Section1;

public class MyRectangle1 {
	public MyPoint1 lu;   // left upper
	public int width;
	public int height;
}
```

### Code05.java

```java
package Section1;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;


public class Code05 {

	static MyRectangle1 [] rects = new MyRectangle1[100];   // class member
	static int n = 0;    			// 데이터의 갯수(사각형의 갯수)

	public static void main(String[] args) {
				
		try {
			Scanner in = new Scanner(new File("data.txt"));

			while(in.hasNext()) {
				
				rects[n] = new MyRectangle1(); // 실수하기 좋은 곳.... new 선언하는것..
				rects[n].lu = new MyPoint1(); // 위와 동일한 것으로, MyRectangle1에서 lu를 생성하지않았으니깐..
				rects[n].lu.x = in.nextInt();
				rects[n].lu.y = in.nextInt();
				rects[n].width = in.nextInt();
				rects[n].height = in.nextInt();
				n++;
			}
			in.close();

			
		} catch (FileNotFoundException e) {
			System.out.println("No data file.");
			System.exit(1);
		}
		
		bubbleSort();
		
		for (int i=0; i<n; i++)
			System.out.println(rects[i].lu.x + " " + rects[i].lu.y + " " + rects[i].width + " " + rects[i].height);
		

	}
	
	private static void bubbleSort() {
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( calcArea(rects[j]) > calcArea(rects[j+1])) {
					MyRectangle1 tmp = rects[j];
					rects[j] = rects[j+1];
					rects[j+1] = tmp;
				}
			}
		}
	}
	
	public static int calcArea( MyRectangle1 r)
	{
		return r.width * r.height;
	}

}

```



# 클래스, 객체, 참조변수 5

- 다항함수는 항들의 합이며 항은 계수와 지수에 의해서 정의된다. 계수는 0이 아닌 정수이고 지수는 음이 아닌 정수라고 가정한다. 

```java
f(x) = -x**5 + 2x **4 -10x -3
```



- ### 다항함수 프로그램 만들기

![class5](https://user-images.githubusercontent.com/45934115/58853087-fe0d0b80-86d3-11e9-8e10-80e2b375763c.JPG)



- `Math.pow( x, term.expo)` 지수승 계산 하는 법...



### Code06.java

```java
package Section1;

import java.util.Scanner;

public class Code06 {

	static Polynomial [] polys = new Polynomial [100];
	static int n = 0;
	
	public static void main(String[] args) {
		
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial();	// 객체 생성, 객체 안에 있는 필드들에 저장.
				polys[n].name = name;
				polys[n].terms = new Term [100];
				polys[n].nTerms = 0;
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					addTerm( polys[index], c, e);
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = calcPolynomial( polys[index], x);
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					printPolynomial( polys[index]);
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();
	}

	private static int calcPolynomial(Polynomial p, int x) {
		int result = 0;
		for (int i = 0; i<p.nTerms; i++)
			result += calcTemr( p.terms[i], x);
		return result;
	}

	private static int calcTemr(Term term, int x) {
		return (int) (term.coef * Math.pow( x, term.expo));  // 지수승 계산법
	}	//  double이 리턴될 수 있어서 타이오류가 뜨는데 (int) (어쩌구저쩌구) 써서 타입 바꿔죽...?
	private static void printPolynomial(Polynomial p) {
		for (int i=0; i<p.nTerms; i++)	{
			printTerm( p.terms[i]);		
			System.out.print("+");
		}
		System.out.println();
	}

	private static void printTerm(Term term) {
		System.out.print(term.coef + "x^" + term.expo);		
	}

	private static void addTerm(Polynomial p, int c, int e) {
		// 자기 자리 찾아서 insert하기... indexMaker 에서 해보았던 것과 비슷한 느낌.
		// 1. 이미 차수가 e인 항이 있을 경우 => 해당 것에 더해주기
		// 2. 아니면 추가하기.
		
		int index = findTerm( p, e);
		if (index != -1) {
			p.terms[index].coef += c;
			// 만약, coef항이 원래는 0이 아니었는데 더하니까 0이되는경우...?? 원랜 없애야되지만 여기선 pass!
		}
		else {
			int i = p.nTerms -1;
			while (i >=0 && p.terms[i].expo < e) {
				p.terms[i+1] = p.terms[i];
				i--;
			}
			p.terms[i+1] = new Term();	// 중요해 중요해 중요해 중요해 중요해
			p.terms[i+1].coef = c;
			p.terms[i+1].expo = e;
			p.nTerms++;
		}			
	}
	

	private static int findTerm(Polynomial p, int e) {
		for (int i = 0; i < p.nTerms && p.terms[i].expo >= e; i++)
			if (p.terms[i].expo == e)
				return i;
		return -1;
	}

	private static int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

}

```

# 메서드와 생성자 1

#### 메서드와 생성자

> - 클래스는 서로 관련있는 데이터들을 하나의 단위로 묶어두기 위한 것이다. ex) 사각형의 꼭지점
> - 하지만 이것이 전부가 아니다.
> - 서로 관련있는 데이터들 뿐 아니라, 그 데이터와 관련이 깊은 메서드(함수)도 함게 묶어 둘 수 있다.
> - 이렇게 함으로써 코드의 `응집도` (cohension)을 높이고 결합도(coupling)을 낯출 수 있다.
> - `응집도`란 연관 있는 코드들끼리 잘 모여있고... 그런 느낌? 결합도는 방, 코드는 사람 친한 친구끼리 묶어두니 방을 오갈 이유가없음



- 다항식 프로그램에서, printTerm과 calcTerm은 class Term과 매우 긴밀한 연관이 있는 메서드들. 이렇게 서로 관련성이 깊은 데이터와 메서드들을 하나의 클래스로 묶어둘 수 있다.



![메서드1](https://user-images.githubusercontent.com/45934115/58931910-8951d400-879c-11e9-8261-7cdb48e79aea.JPG)

​				



![메서드2](https://user-images.githubusercontent.com/45934115/58931983-cae27f00-879c-11e9-931a-50dba8d64469.JPG)



- class는 설계도일 뿐, 실체가 아니다.
- 개게를 만들어주고 객체 안의 메서드들이 실행되면서 존재의 의미를 갖는다.



#### 객체란?

> - 객체 지향 프로그래밍에서 객체란 "데이터" + "메서드"이다. 데이터는 객체의 "정적속성"을 표현하며, 메서드는 객체의 "기능(동적 속성)"을 표현한다.
> - 자전거는 "모양, 무게, 크기, 브랜드"등의 정적 속성(데이터)과 "달린다, 정지한다, 뒤로 간다"등의 기능을 가진다.
> - 하나의 항(term)은 "계수와 차수"라는 정적 속성과 "x의 값을 주면 자신의 값을 계산해 준다", "화면에 출력해 준다"등의 기능을 가진다.



![메서드3](https://user-images.githubusercontent.com/45934115/58932166-8c998f80-879d-11e9-95d7-4c3ffbaa70fc.JPG)



# 메서드와 생성자 2

#### 생성자

> - 클래스 안에 그 클래스와 동일한 이름을 가지며 return 타입이 없는 특별한 메서드를 둘 수 있다. 이 것을 생성자(constructor)라고 부른다.
> - 생성자는 new 명령으로 객체가 생성될 때 자동으로 실행된다. 주 목적은 객체의 데이터 필드의 값을 초기화하는 것이다.

![메서드4](https://user-images.githubusercontent.com/45934115/58934369-3c263000-87a5-11e9-9e71-53c7cd2cda3a.JPG)

- 클래스 자체 이름과 동일한 메서드...  
- return 타입이 아예 없다는 두가지 특징!



### Term3.java

```java
package section2;

public class Term3 {
	public int coef;
	public int expo;
	
	public Term3(int c, int e)
	{
		coef = c;
		expo = e;
	}
	
	public int calcTerm(int x) {
		return (int) (coef * Math.pow( x, expo));  
	}	
	
	public void printTerm() {
		System.out.print(coef + "x^" + expo);		
	}
	
}

```



### Polynomial3.java

```java
package section2;

public class Polynomial3 {
	public char name;
	public Term3 [] terms;	//	다항식의 이름
	public int nTerms; 		//	다항의 갯수
	
	
	public Polynomial3()
	{
		nTerms = 0;
		terms = new Term3 [100];
	}
	
//	타입, 받는 매개변수가 다르기 때문에 여러 생성자를 가질수 있음 동일한 이름이지만...
		
	public Polynomial3( char name)
	{
		this.name = name;   // this.name은 맨 위의 name, 뒤에 name은 매개변수 name
		nTerms = 0;
		terms = new Term3 [100];
	}
	
	public void addTerm( int c, int e ) {
		// 자기 자리 찾아서 insert하기... indexMaker 에서 해보았던 것과 비슷한 느낌.
		// 1. 이미 차수가 e인 항이 있을 경우 => 해당 것에 더해주기
		// 2. 아니면 추가하기.
		
		int index = findTerm( e );
		if (index != -1) {
			terms[index].coef += c;
			// 만약, coef항이 원래는 0이 아니었는데 더하니까 0이되는경우...?? 원랜 없애야되지만 여기선 pass!
		}
		else {
			int i = nTerms -1;
			while (i >=0 && terms[i].expo < e) {
				terms[i+1] = terms[i];
				i--;
			}
			terms[i+1] = new Term3(c, e);	// 중요해 중요해 중요해 중요해 중요해    필요없어진 밑에 두줄
//			terms[i+1].coef = c;
//			terms[i+1].expo = e;
			nTerms++;
		}			
	}
	
	
	public int findTerm( int e) {
		for (int i = 0; i < nTerms && terms[i].expo >= e; i++)
			if (terms[i].expo == e)
				return i;
		return -1;
	}
	
	
	
	
	
	public int calcPolynomial(int x) {
		int result = 0;
		for (int i = 0; i<nTerms; i++)
			result += terms[i].calcTerm(x);
		return result;
	}

	
	public void printPolynomial() {
		for (int i=0; i < nTerms; i++)	{
			terms[i].printTerm();		
			System.out.print("+");
		}
		System.out.println();
	}
	
}

```



### Code08.java

```java
package section2;

import java.util.Scanner;

public class Code08 {

	static Polynomial3 [] polys = new Polynomial3 [100];
	static int n = 0;
	
	public static void main(String[] args) {
		
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial3( name );	// 객체 생성, 객체 안에 있는 필드들에 저장.
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					 polys[index].addTerm( c, e );
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = polys[index].calcPolynomial(x); // 멤버로 갖고있어서..
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					polys[index].printPolynomial();
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();
	}
	



	private static int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

}

```

- toString() 이라는 이름은 특별한 아이 이렇게 해주는게 좋음...  이름을 꼭 이렇게 지어주기로하자.

- 코드의 응집도를 높였을 때의 장점,,
  - 어떤 이유 때문에 사각형 하나를 표현할 때 꼭지점, 너비, 높이를 이용할 때와 대각선 꼭지점 두개를 이용해서 표현 할 때 Code09도  엄청나게 수정해서 써야되는데,
  - 저런 표현 방법을 쓰면 MyRectangle2만 고치면 된다.
  - 



### MyPoint2.java

```java
package section2;

public class MyPoint2 {
	public int x;
	public int y;
	
	public MyPoint2( int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}


```



### MyRectangle2.java

```java
package section2;

public class MyRectangle2 {
	public MyPoint2 lu;   // left upper
	public int width;
	public int height;
	
	public MyRectangle2( int x, int y, int w, int h) {
		lu = new MyPoint2( x, y );
		width = w;
		height = h;
	}
	
	public int calcArea( )
	{
		return width * height;
	}
	
	
	// toString() 이라는 이름은 특별한 아이 이렇게 해주는게 좋음... 
	public String toString()
	{
		return "(" + lu.x + " " + lu.y + ")" + width + " " + height;
	}	
}
```



### Code09.java

```java
package section2;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;


public class Code09 {

	static MyRectangle2 [] rects = new MyRectangle2[100];   // class member
	static int n = 0;    			// 데이터의 갯수(사각형의 갯수)

	public static void main(String[] args) {
				
		try {
			Scanner in = new Scanner(new File("data.txt"));

			while(in.hasNext()) {
				
				int x = in.nextInt();
				int y = in.nextInt();
				int w = in.nextInt();
				int h = in.nextInt();
				
				rects[n] = new MyRectangle2( x, y, w, h); // 실수하기 좋은 곳.... new 선언하는것..
//				rects[n++] = new MyRectangle2( in.nextInt(), in.nextInt(), in.nextInt(), in.nextInt()); // 실수하기 좋은 곳.... new 선언하는것..
				n++;
			}
			in.close();

			
		} catch (FileNotFoundException e) {
			System.out.println("No data file.");
			System.exit(1);
		}
		
		bubbleSort();
		
		for (int i=0; i<n; i++)
			System.out.println( rects[i].toString() );	// 조금 더 코드가 간결해지는 느낌.
		
	}
	
	// 하나의 사각형에 해당하는 함수가 아니니까 버블소트는 여기 두자..
	private static void bubbleSort() {
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( rects[j].calcArea() > rects[j+1].calcArea()) {
					MyRectangle2 tmp = rects[j];
					rects[j] = rects[j+1];
					rects[j+1] = tmp;
				}
			}
		}
	}
}

```



# 메서드와 생성자3

#### 다각형과 점

- 입력으로 하나의 직교 다각형과 또 하나의 점 p가 주어질 대 그 점이 다각형의 ㅐㄴ부에 있는지 외부에 있는지 판단하는 프로그램을 만들어보자!

- 점에서 시작하여 한 방향으로 무한히 뻗어가는 아무 직선이나 하나 그어서 그것이 다각형의 변과 짝수번 교차하면 외부, 홀수 번 교차하면 내부에 있다.



### OrthoPolygon.java

```java
package section2;

public class OrthoPolygon {
	
	public int n;
	public MyPoint2 [] vertices; // 꼭지점

	// 다각형 객체 생성,
	public OrthoPolygon( int k ) {	// 꼭지점의 갯수
		n = 0;	// 실제로 저장된 꼭지점의 갯수
		vertices = new MyPoint2 [k];
			
	}
	
	// 꼭지점 차례로 하나씩 추가해주는 메서드
	public void addVertex( int x, int y)
	{
		
		vertices[n++] = new MyPoint2(x, y);
	
	}
	
	public int maxX()
	{
		int max = vertices[0].x;
		for (int i=0; i<n; i++ ) {
			if (vertices[i].x > max)
				max = vertices[i].x;
		}
		return max;
	}
	
	public boolean contains( MyPoint2 p ) {
		
		OrthoLine arrow = new OrthoLine( p, new MyPoint2( maxX()+1, p.y ) );
		int count = 0;
		for (int i=0; i<n; i++) {
			OrthoLine edge = new OrthoLine( vertices[i], vertices[ (i+1) % n ] );
			if ( arrow.intersects(edge))
				count++;
		}
		return (count % 2 == 1);    //홀수면 포함
	}
	
}

```



### OrthoLine.java

```java
package section2;

public class OrthoLine {
	public MyPoint2 u;
	public MyPoint2 v;
	
	public OrthoLine ( MyPoint2 p, MyPoint2 q)
	{
		u = p;
		v = q;
		if ( p.x > q.x || p.x == q.x && p.y > q.y)
			swap();
	}
	
	private void swap() {
		MyPoint2 tmp = u;
		u = v;
		v = tmp;		
	}

	public OrthoLine (int x1, int y1, int x2, int y2)
	{
		u = new MyPoint2(x1, y1);
		v = new MyPoint2(x2, y2);
	}
		
	public boolean isVertical()	// 어차피 수직 아니면 수평이니깐
	{
		return u.x == v.x;	// true
	}
	
	
	// 이미 자신이 선분 하나의 메서드 중 하나인데.... 선분 2개를 받아서 받는건 역량 초과인듯...
	// 그니까 하나 더 추가로 받아서 비교해보는게 옳은 방법같음.
	public boolean intersects( OrthoLine other )
	{
		if ( isVertical() && !other.isVertical() ) 	// 내가 수직 니가 수평
			return ( other.u.x < u.x && other.v.x > u.x && u.y < other.u.y && v.y > other.u.y);   
		
		else if (!isVertical() && other.isVertical()) 	// 니가 수직 내가 수평
			return ( other.u.y < u.y && other.v.y > u.y && u.x < other.u.x && v.x > other.u.x );
		
		else 
			return false;
	}
	
	
}

```



### MyPoint2.java

```java
package section2;

public class MyPoint2 {
	public int x;
	public int y;
	
	public MyPoint2( int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}


```