#  문자열 다루기 1

- String [] 라는 문자열 배열

- class 내 외부에 모두 가능, 지역변수, 전역변수로 사용 가능

- 대신 외부에 두려면 static 이란걸 붙혀야함

- 입력받는데는 마찬가지로 Scanner를 사용하자.

### Lesson.java

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Lesson {
	
//		지금은 지역변수로 사용, 함수 외부에 둬서 전역 변수처럼 사용할 수도 있음
//	대신 외부에 두려면 static 이란걸 붙혀야함
	static String [] names = new String [1000]; 
	static int [] numbers = new int[1000];
//	int [] numbers;
//	numbers = new int [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
		Scanner sc;
		try {
			sc = new Scanner( new File("input.txt") );			
			
			while(sc.hasNext() ) {
				
				names[n] = sc.next(); 
				numbers[n] = sc.nextInt();
				n++;
			}
			
			sc.close();
			
		} catch (FileNotFoundException e) {	// 해당파일이 없으면 어쩔거냐 정하는 부분, 무조건 해야되는건아님.
			System.out.print("No file"); //내 맘대로 처리하면 됨.
			System.exit(1);
		}

		bubbleSort(n, names, numbers);
		
		for (int i=0; i<n; i++) {
			System.out.println(names[i] + "," +  numbers[i] );
			
		}
		

	}
	
	static public void bubbleSort(int n, String [] names, int [] numbers)// call-by-value
	{
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( names[j].compareTo(names[j+1] ) > 0 ) {  // ==0  str1.equals(str2) 문자열 같은지 비교하기 
					// swqp numbers [j] and numbers [j+1]
					int tmp = numbers[j];
					numbers[j] = numbers[j+1];
					numbers[j+1] = tmp;
							
					String tmpstr = names[j];
					names[j] = names[j+1];
					names[j+1] = tmpstr;
				} 			
				
			}
		}
	}
}
```



# 문자열 다루기2

- #### 인덱스 메이커

- 입력으로 하나의 텍스트 파일 일기
- 텍스트 파일에 등장하는 단어들의 목록 만들고, 단어가 텍스트 파일에 등장하는 횟수 세기
- 사용자가 요청하면 단어 목록을 하나의 파일로 저장
- 사용자가 단어 검색하면 단어가 텍스트 파일에 몇번 등장하는지 출력

- `java.lang.ArrayIndexOutOfBoundsException` 오류 => 배열의 인덱스를 벗어났다.

- `PrintWriter out`

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				addWord(str);  // 목록에서 검사해서 상황에 따라 다르게하기
			}
			
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static void addWord(String str) {
		int index = findWord( str );	// returns -1 if not found
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			words[n] = str;
			count[n] = 1;
			n++;
		}
	}
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 문자열 다루기 3

- code 22 개선하자!
- 소수점, 특수기호가 단어에 포함, 숫자 등이 단어에 포함, 대소문자는 맨밑에 수정해서 됬지만, 알파벳 순서대로 ㄱㄱ
- String 클래스 기본 메서드

![1](https://user-images.githubusercontent.com/45934115/58763366-af0c8c80-8594-11e9-96f3-83acc079320c.PNG)



- ex) "-?*he-llo+=() 면 he-llo 가 남게 하겠다!

### Code23 이 되어야하지만 Code 22에 쓴 친구

```java
package Section3;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Code22 {

	static String [] words = new String [100000];
	static int [] count = new int [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + words[index] + " appears " + count[index] + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(words[i] + " " + count[i]);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			count[index]++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && words[i].compareTo(str) > 0) {
				words[i+1] = words[i];
				count[i+1] = count[i];
				i--;
			}
			words[i+1] = str;
			count[i+1] = 1;
			n++;
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (words[i].equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 1

- 전화번호를 예로 들때 이름, 번호를 각자 다른 배열에 저장하는게 불편하다고 할 수있다.
- 왜냐면 함께하지 않으면 의미가 없는 데이터로 취급되기 때문이다 쌍으로 존재할때 의미있는 데이터
- 한 사람에 대해 5, 6개 이상의 데이터를 저장한다고 생각해보면 이해하기 쉽겠지

###  클래스란..

> - 한 사람의 "이름"과 "전화번호"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이 두 가지 데잍를 서로 별개의 변수에 저장하면 우리가 이름 데이터를 옮길 때 마다 전화번호 데이터도 따로 옮겨줘야 한다.
> - 만약 각 사람에 대해서 이름과 전화번호 뿐만 아니라 주소, 이메일 등 여러 가지 데이터를 저장한다면 이 불편은 더 심해질 것이다.
> - 인덱스 메이커 프로그램에서도 "하나의 단어"와 그 단어의 "등장 횟수"는 항상 같이 붙어다녀야 하는 데이터이다.
> - 이렇게 서로 관련있는 데이터들을 하나의 단위로 묶어두면 편할 것이다.
> - 이것이 클래스라는 개념이 등장하는 가장 기본적인 이유이다.
> - 클래스는 결국 하나의 `타입` 이다.     마치 int x에 5를 저장하는 것 처럼 Person1 a에 어떤걸 저장하겠다 이런 느낌
> - 다만 int, double 처럼 Java가 미리 정해놓은 타입이 아니라 사용자가 정의한 새로운 타입이라는 의미에서 `사용자 정의타입`이라고 부르기도 한다.
> - int 혹은 double형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
>
> ```java
> int count = 0;
> Person1 first = newPerson1();
> ```
>
> 

- 하나의 파일에 하나의 클래스라고 생각하자!



### Person1.java

```java
package Section1;

public class Person1 {
		
	public String name;	// 우선 public이 뭔진 궁금해하지말자		field, data member
	public String number;
	
}

```



### Code01.java

```java
package Section1;

public class Code01 {

	public static void main(String[] args) {
		
		int x;
		x = 100;
		
		double y = 1.0023;
		
		Person1 first;
		first = new Person1();  // new 는 생성하는 행위 이 생성한 것이 object(객체)
		
		// 위 아래 구조를 보쟈 비슷하다.
		// 마찬가지로 합칠 수 있다.
		
		int [] data;
		data = new int [100];
		data[0] = 5;		
		
		first.name = "John";			// first 객체의 name필드, number 필드에 저장하기
		first.number = "0102483120";
		
		System.out.println("Name: " + first.name + ", Number: " + first.number );
		
		// 배열도 된다    배열 한칸한칸이 Person1 타입을 갖는 배열을 만든거.
		Person1 [] members = new Person1 [10];
		members[0] = first;
		members[1] = new Person1();
		members[1].name = "David";
		members[1].number = "2873548327458";
		
		System.out.println("Name: " + members[1].name + ", Number: " + members[1].number );
		
		
	}

}
```



### 프리미티브 타입 vs 클래스

![class1](https://user-images.githubusercontent.com/45934115/58777691-79a28600-860a-11e9-8f6b-1d75079e1805.JPG)

- first라는 변수 안에 이름, 번호가 저장되는게 아니고   객체(object)는 new 명령으로 따로 만들어야 하고, 변수 first 안에는 참조를 저장한다. 주소를 저장한다.



### 클래스와 객체

![class2](https://user-images.githubusercontent.com/45934115/58777802-09e0cb00-860b-11e9-90bb-9ba4539bdfbe.JPG)



## 쉽게 설명하자면

- ### 모든 프리미티브 타입의 변수는 보통 변수이다.

- ### 즉 변수 자체에 값이 저장된다.

- ### 프리미티브 타입이 아닌 모든 변수는 참조 변수이다.

- ### 즉 실제 데이터가 저장될 "객체"는 new 명령으로 따로 만들어야 하고, 참조 변수에는 그 객체의 주소를 저장한다.



# 클래스, 객체, 참조변수 2



- int 는 프리미티브 타입이지만, int [] int형 배열은 프리미티브 타입이 아니다.
- 그렇기 때문에 members 는 참조변수이겠지...?    각 칸은 int 타입의 프리미티브 변수

![class3](https://user-images.githubusercontent.com/45934115/58779338-90e47200-8610-11e9-9f6e-3282078bbb9c.JPG)



- Person1 []  members = new Person1[8];
- 에서 members는 당연히 참조변수, 각 칸은 Person1이라는 타입을 갖게 됨. 위의 것이 int 타입이듯이.
- 따라서 저 한칸은 Person1타입의 참조변수 이다. 



### 값에 의한 호출:배열

![class4](https://user-images.githubusercontent.com/45934115/58779685-a4dca380-8611-11e9-9e72-ead499c8b187.JPG)



- 변수 배열 data는 복사될 때 주소를 복사시켜줘서 data라는 친구랑 data2라는 친구가 복사된 친구라면 하나만 바꿔도 둘다 변경하게 된다. 주소에 있는 값이 바뀌고, 그 것을 양쪽에서 동시에 바라보고 있기 때문에.



### Code02.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

}

```



# 클래스, 객체, 참조변수 3

- Code02에서 버블솔트 함수 추가하기!



### Code03.java

```java
package Section1;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class Code3 {

	static Person1 [] members = new Person1 [1000];
	static int n=0;
	
	public static void main(String[] args) {
		
//		members = new Person1 [1000];
		
		try {
			Scanner in = new Scanner(new File("input.txt"));
			while (in.hasNext()) {
				String nm = in.next();
				String nb = in.next();
				
				members[n] = new Person1();	// 잊기 너무너무 쉬운 부분
						
				members[n].name = nm;
				members[n].number = nb;
				n++;
				
			}
			
			in.close();
			
		} catch (FileNotFoundException e) {
			
			System.out.println("No data file");
			
		}
		
		bubbleSort();	// n과 members가 메인함수 밖에 있기 때문에 매개변수가 필요 없음 ,,,즉, 지역변수가 아니다. 
		for (int i=0; i<n; i++)
			System.out.println(members[i].name + " " + members[i].number);
		 
		
	}

	private static void bubbleSort() {
		
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( members[j].name.compareTo(members[j+1].name) > 0 ) {	//  compare names of j -th and (j+1) -th person
					// swap
					Person1 tmp = members[j];
					members[j] = members[j+1];
					members[j+1] = tmp;
					
					
				}
			}
		}
		
	}

}

```



- code22 수정해서 만들어보쟈 class 이용

- #### 마찬가지로 코드의 135번째 줄에서 객체를 생성해주는 것을 잊지말자!!

### Code03.java

```java
package Section1;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

public class IndexMaker {
	
	
//	static String [] words = new String [100000];
//	static int [] count = new int [100000];
	
	static Item [] items = new Item [100000];
	static int n= 0;
	
	public static void main(String[] args) {
		
		
		Scanner kb = new Scanner(System.in);
		
		while(true) {
			
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("read") ) {
				String fileName = kb.next();
				makeIndex( fileName );
			}
			else if (command.equals("find")) {
				String str = kb.next();
				int index = findWord(str);
				if (index > -1) {
					System.out.println("The word " + items[index].word + " appears " + items[index].count + " times.");
				}
				else
					System.out.println("The word" + str + " does not appear.");
			}
			else if (command.equals("saveas")) {
				String fileName = kb.next();
				saveAs( fileName );
			}
			else if (command.equals("exit")) {
				break;
			}
			
		}
		kb.close();
	}
		

	
	static void saveAs(String fileName) {
		
		PrintWriter outFile;
		try {
			outFile = new PrintWriter(new FileWriter(fileName));	// out 부분은 내가정하는 이름
			
			for (int i=0; i<n; i++)
				outFile.println(items[i].word + " " + items[i].count);
		
			
			outFile.close();
		} catch (IOException e) {
			System.out.println("Save failed");
		} 
		
		
		
		
	}
	
	
	static void makeIndex( String fileName) {
		
		try {
			Scanner inFile = new Scanner( new File(fileName));
			while(inFile.hasNext()) {
				String str = inFile.next();
				
				
				String trimmed = trimming(str);
				
				if (trimmed != null) {
					String t = trimmed.toLowerCase();
					addWord( t );  // 목록에서 검사해서 상황에 따라 다르게하기
						
				}
			}
			
			
			inFile.close();
		} catch (FileNotFoundException e) {
			System.out.println("no File");
			return;  //없다고 종료하기보단 다시 기회를 주자
		}		
	}

	static String trimming(String str) {
		
		int i= 0, j= str.length()-1;
		while( i <= str.length()-1 && !Character.isLetter(str.charAt(i) ) ) //while i번째 character is not letter
			i++;
		
		while( j >=0 && !Character.isLetter(str.charAt(j) ) ) //while i번째 character is not letter
			j--;
		
		if (i > j)    // trimming을 했더니 남는게 없다면
			return null;
		
		return str.substring(i, j+1);	// [  ) 가 되어서 i부터 j까지 잘라낸 문자열을 반환하는 substring
		
										// i <= .... <= j
	}



	static void addWord(String str) {
		
		int index = findWord( str );	// returns -1 if not found
	
		if (index != -1) {		// found words[index] == str
			items[index].count++;
		}
		else {	// not found
			
			int i = n-1;
			while (i >= 0 && items[i].word.compareTo(str) > 0) {
				items[i+1] = items[i];
				i--;
			}
						
			items[i+1] = new Item();		// 객체를 생성하고 거기 담는것을 잊지말자!
			items[i+1].word = str;
			items[i+1].count = 1;
			n++;
			
		}
	}
	
	
	static int findWord(String str) {
		for (int i=0; i < n; i ++)
			if (items[i].word.equalsIgnoreCase((str)) )
				return i;
		return -1;
	}	
	
	
}

```



# 클래스, 객체, 참조변수 4

- `static` 에 대한 정확한 설명은 2-3에서 수업할거지만 main함수가 있는 Code로 시작하는 파일에선
- `static`에 변수들을 저장하고 있음을 인지하고 있자.

### MyPoint1.java

```java
package Section1;

public class MyPoint1 {
	public int x;
	public int y;
	
}
```

### MyRectangle1.java

```java
package Section1;

public class MyRectangle1 {
	public MyPoint1 lu;   // left upper
	public int width;
	public int height;
}
```

### Code05.java

```java
package Section1;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;


public class Code05 {

	static MyRectangle1 [] rects = new MyRectangle1[100];   // class member
	static int n = 0;    			// 데이터의 갯수(사각형의 갯수)

	public static void main(String[] args) {
				
		try {
			Scanner in = new Scanner(new File("data.txt"));

			while(in.hasNext()) {
				
				rects[n] = new MyRectangle1(); // 실수하기 좋은 곳.... new 선언하는것..
				rects[n].lu = new MyPoint1(); // 위와 동일한 것으로, MyRectangle1에서 lu를 생성하지않았으니깐..
				rects[n].lu.x = in.nextInt();
				rects[n].lu.y = in.nextInt();
				rects[n].width = in.nextInt();
				rects[n].height = in.nextInt();
				n++;
			}
			in.close();

			
		} catch (FileNotFoundException e) {
			System.out.println("No data file.");
			System.exit(1);
		}
		
		bubbleSort();
		
		for (int i=0; i<n; i++)
			System.out.println(rects[i].lu.x + " " + rects[i].lu.y + " " + rects[i].width + " " + rects[i].height);
		

	}
	
	private static void bubbleSort() {
		for (int i=n-1; i>0; i--) {
			for (int j=0; j<i; j++) {
				if ( calcArea(rects[j]) > calcArea(rects[j+1])) {
					MyRectangle1 tmp = rects[j];
					rects[j] = rects[j+1];
					rects[j+1] = tmp;
				}
			}
		}
	}
	
	public static int calcArea( MyRectangle1 r)
	{
		return r.width * r.height;
	}

}

```



# 클래스, 객체, 참조변수 5

- 다항함수는 항들의 합이며 항은 계수와 지수에 의해서 정의된다. 계수는 0이 아닌 정수이고 지수는 음이 아닌 정수라고 가정한다. 

```java
f(x) = -x**5 + 2x **4 -10x -3
```



- ### 다항함수 프로그램 만들기

![class5](https://user-images.githubusercontent.com/45934115/58853087-fe0d0b80-86d3-11e9-8e10-80e2b375763c.JPG)



- `Math.pow( x, term.expo)` 지수승 계산 하는 법...



### Code06.java

```java
package Section1;

import java.util.Scanner;

public class Code06 {

	static Polynomial [] polys = new Polynomial [100];
	static int n = 0;
	
	public static void main(String[] args) {
		
		Scanner kb = new Scanner( System.in );
		while (true) {
			System.out.print("$ ");
			String command = kb.next();
			if (command.equals("create")) {
				char name = kb.next().charAt(0); //길이가 1인 문자열로 바꾸는 꼼수.
				
				polys[n] = new Polynomial();	// 객체 생성, 객체 안에 있는 필드들에 저장.
				polys[n].name = name;
				polys[n].terms = new Term [100];
				polys[n].nTerms = 0;
				n++;
			}
			else if (command.equals("add")) {	// add f 2 3
				char name = kb.next().charAt(0);
				int index = find(name);	// f 찾기
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int c = kb.nextInt();	// 2
					int e = kb.nextInt();	// 3
					addTerm( polys[index], c, e);
				}
				
			}
			else if (command.equals("calc")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					int x = kb.nextInt();
					int result = calcPolynomial( polys[index], x);
					System.out.println(result);
				}
			}
			else if (command.equals("print")) {
				char name = kb.next().charAt(0);
				int index = find(name);
				if (index == -1) {
					System.out.println("No such polynomial exists.");
				}
				else {
					printPolynomial( polys[index]);
				}				
				
			}
			else if (command.equals("exit")) 
				break;			
		}		
		kb.close();
	}

	private static int calcPolynomial(Polynomial p, int x) {
		int result = 0;
		for (int i = 0; i<p.nTerms; i++)
			result += calcTemr( p.terms[i], x);
		return result;
	}

	private static int calcTemr(Term term, int x) {
		return (int) (term.coef * Math.pow( x, term.expo));  // 지수승 계산법
	}	//  double이 리턴될 수 있어서 타이오류가 뜨는데 (int) (어쩌구저쩌구) 써서 타입 바꿔죽...?
	private static void printPolynomial(Polynomial p) {
		for (int i=0; i<p.nTerms; i++)	{
			printTerm( p.terms[i]);		
			System.out.print("+");
		}
		System.out.println();
	}

	private static void printTerm(Term term) {
		System.out.print(term.coef + "x^" + term.expo);		
	}

	private static void addTerm(Polynomial p, int c, int e) {
		// 자기 자리 찾아서 insert하기... indexMaker 에서 해보았던 것과 비슷한 느낌.
		// 1. 이미 차수가 e인 항이 있을 경우 => 해당 것에 더해주기
		// 2. 아니면 추가하기.
		
		int index = findTerm( p, e);
		if (index != -1) {
			p.terms[index].coef += c;
			// 만약, coef항이 원래는 0이 아니었는데 더하니까 0이되는경우...?? 원랜 없애야되지만 여기선 pass!
		}
		else {
			int i = p.nTerms -1;
			while (i >=0 && p.terms[i].expo < e) {
				p.terms[i+1] = p.terms[i];
				i--;
			}
			p.terms[i+1] = new Term();	// 중요해 중요해 중요해 중요해 중요해
			p.terms[i+1].coef = c;
			p.terms[i+1].expo = e;
			p.nTerms++;
		}			
	}
	

	private static int findTerm(Polynomial p, int e) {
		for (int i = 0; i < p.nTerms && p.terms[i].expo >= e; i++)
			if (p.terms[i].expo == e)
				return i;
		return -1;
	}

	private static int find(char name) {
		for (int i=0; i<n; i++)
			if (polys[i].name == name)
				return i;
		return -1;
	}

}

```